<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>The Prometheans | Our Team</title>

    <!-- SEO -->
    <meta name="description" content="The Prometheans is a digital collection built on XION, born from the community.">
    <meta name="robots" content="index, follow">
    <link rel="canonical" href="https://theprometheans.io/our_team">

    <!-- Open Graph -->
    <meta property="og:type" content="website">
    <meta property="og:url" content="https://theprometheans.io/our_team">
    <meta property="og:site_name" content="The Prometheans">
    <meta property="og:title" content="The Prometheans | Our Team">
    <meta property="og:description" content="The Prometheans is a digital collection built on XION, born from the community.">
    <meta property="og:image" content="https://theprometheans.io/assets/thumbnail.png">
    <meta property="og:image:alt" content="The Prometheans">
    <meta property="og:image:width" content="1200">
    <meta property="og:image:height" content="630">

    <!-- Twitter / X Card -->
    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:site" content="@theprometheans">
    <meta name="twitter:title" content="The Prometheans | Our Team">
    <meta name="twitter:description" content="The Prometheans is a digital collection built on XION, born from the community.">
    <meta name="twitter:image" content="https://theprometheans.io/assets/thumbnail.png">
    <meta name="twitter:image:alt" content="The Prometheans">

    <!-- Theme-aware favicon -->
    <link id="favicon" rel="icon" type="image/png" href="assets/light_favicon.png">
    <script>
        (function() {
            function updateFavicon() {
                const favicon = document.getElementById('favicon');
                if (window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches) {
                    favicon.href = 'assets/dark_favicon.png';
                } else {
                    favicon.href = 'assets/light_favicon.png';
                }
            }
            // Set initial favicon
            updateFavicon();
            // Listen for theme changes
            if (window.matchMedia) {
                window.matchMedia('(prefers-color-scheme: dark)').addEventListener('change', updateFavicon);
            }
        })();
    </script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Finger+Paint&display=swap" rel="stylesheet">
    <link rel="preload" href="assets/digital.ttf" as="font" type="font/ttf" crossorigin>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
            overflow-y: auto; /* Enable vertical scrolling */
            overflow-x: hidden; /* Prevent horizontal scrolling */
        }

        body {
            font-family: 'Finger Paint', sans-serif;
            background: #000000;
            color: #ffffff;
            margin: 0;
            padding: 0;
            overflow-y: auto; /* Enable vertical scrolling */
            overflow-x: hidden; /* Prevent horizontal scrolling */
            position: relative; /* Allow scrolling */
            width: 100%;
            min-height: 100vh;
        }
        
        /* Wrapper to maintain 1920x1080 aspect ratio */
        body {
            min-height: 100vh;
            background: url('assets/bg_our_team.png') no-repeat center center;
            background-size: cover;
            background-attachment: fixed;
            position: relative;
        }
        
        /* Disable fixed background on mobile for better performance and to prevent scroll issues */
        /* Make background repeat on mobile to fill the entire page */
        @media (max-width: 1024px) {
            body {
                background-attachment: scroll;
                background-repeat: repeat;
                background-size: auto;
                background-position: top left;
            }
        }
        
        .page-wrapper {
            position: relative;
            width: 100%;
            min-height: 100vh;
            padding-top: 120px;
            padding-bottom: 60px;
        }
        
        /* Enable vertical scrolling when content extends beyond viewport */
        html {
            overflow-y: auto;
            overflow-x: hidden;
        }
        
        body {
            overflow-y: auto;
            overflow-x: hidden;
        }

        @font-face {
            font-family: 'Digital';
            src: url('assets/digital.ttf') format('truetype');
            font-weight: normal;
            font-style: normal;
            font-display: block;
        }

        /* Hide page content until loading is complete */
        body.loading {
            overflow: hidden;
        }

        body.loading > *:not(.loading-screen) {
            opacity: 0;
            visibility: hidden;
        }

        body.loaded > *:not(.loading-screen) {
            opacity: 1;
            visibility: visible;
            transition: opacity 0.5s ease-in;
        }

        /* Loading Screen */
        .loading-screen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: #000000;
            z-index: 10000;
            display: flex;
            align-items: center;
            justify-content: center;
            opacity: 1;
            transition: opacity 0.3s ease-out;
            pointer-events: none;
        }

        .loading-screen.hidden {
            opacity: 0;
            pointer-events: none;
        }

        .loading-screen-content {
            position: relative;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            text-align: center;
        }

        /* Responsive Design for Loading Screen */
        @media (max-width: 768px) {
            .loading-percentage {
                font-size: 2rem;
            }
        }

        @media (max-width: 480px) {
            .loading-percentage {
                font-size: 1.5rem;
                text-shadow: 
                    0 0 3px rgba(255, 255, 255, 0.4),
                    0 0 6px rgba(255, 255, 255, 0.3);
            }
        }

        @media (max-width: 360px) {
            .loading-percentage {
                font-size: 1.2rem;
            }
        }

        .loading-percentage {
            margin-top: 0;
            font-family: 'Digital', 'Courier New', 'Monaco', 'Menlo', monospace;
            font-size: 2.5rem;
            font-weight: bold;
            color: #ffffff;
            text-shadow: 
                0 0 5px rgba(255, 255, 255, 0.4),
                0 0 10px rgba(255, 255, 255, 0.3);
            letter-spacing: 0.2em;
            opacity: 1 !important;
            font-variant-numeric: tabular-nums;
            display: block !important;
            visibility: visible !important;
            text-align: center;
        }

        .loading-percentage.glitch {
            animation: glitchEffect 0.4s steps(10) !important;
        }

        @keyframes glitchEffect {
            0% {
                transform: translate(0, 0);
                text-shadow: 
                    0 0 10px rgba(255, 255, 255, 0.8),
                    0 0 20px rgba(255, 255, 255, 0.6),
                    0 0 30px rgba(255, 255, 255, 0.4);
                color: #ffffff;
            }
            10% {
                transform: translate(-3px, 2px) scale(1.02);
                text-shadow: 
                    -3px 2px 15px rgba(255, 0, 0, 1),
                    3px -2px 15px rgba(0, 255, 255, 1);
                color: #ff00ff;
            }
            20% {
                transform: translate(3px, -2px) scale(0.98);
                text-shadow: 
                    3px -2px 15px rgba(255, 0, 0, 1),
                    -3px 2px 15px rgba(0, 255, 255, 1);
                color: #00ffff;
            }
            30% {
                transform: translate(-2px, 2px) scale(1.01);
                text-shadow: 
                    -2px 2px 12px rgba(255, 0, 0, 0.9),
                    2px -2px 12px rgba(0, 255, 255, 0.9);
                color: #ff00ff;
            }
            40% {
                transform: translate(2px, -2px) scale(0.99);
                text-shadow: 
                    2px -2px 12px rgba(255, 0, 0, 0.9),
                    -2px 2px 12px rgba(0, 255, 255, 0.9);
                color: #00ffff;
            }
            50% {
                transform: translate(-3px, -3px) scale(1.02);
                text-shadow: 
                    -3px -3px 15px rgba(255, 0, 0, 1),
                    3px 3px 15px rgba(0, 255, 255, 1);
                color: #ff00ff;
            }
            60% {
                transform: translate(3px, 3px) scale(0.98);
                text-shadow: 
                    3px 3px 15px rgba(255, 0, 0, 1),
                    -3px -3px 15px rgba(0, 255, 255, 1);
                color: #00ffff;
            }
            70% {
                transform: translate(-1px, 0) scale(1.01);
                text-shadow: 
                    -1px 0 10px rgba(255, 0, 0, 0.7),
                    1px 0 10px rgba(0, 255, 255, 0.7);
                color: #ff00ff;
            }
            80% {
                transform: translate(1px, 0) scale(0.99);
                text-shadow: 
                    1px 0 10px rgba(255, 0, 0, 0.7),
                    -1px 0 10px rgba(0, 255, 255, 0.7);
                color: #00ffff;
            }
            90% {
                transform: translate(-1px, 1px) scale(1.005);
                text-shadow: 
                    -1px 1px 8px rgba(255, 0, 0, 0.6),
                    1px -1px 8px rgba(0, 255, 255, 0.6);
                color: #ff00ff;
            }
            100% {
                transform: translate(0, 0) scale(1);
                text-shadow: 
                    0 0 10px rgba(255, 255, 255, 0.8),
                    0 0 20px rgba(255, 255, 255, 0.6),
                    0 0 30px rgba(255, 255, 255, 0.4);
                color: #ffffff;
            }
        }

        @keyframes fadeInPercentage {
            from {
                opacity: 0;
                transform: translateY(10px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        .loading-percentage::after {
            content: '%';
            margin-left: 5px;
        }

        /* Header with Logo */
        .header-logo {
            position: fixed;
            top: 30px;
            left: 30px;
            z-index: 1000;
        }

        .header-logo img {
            max-width: 150px;
            height: auto;
            cursor: pointer;
            filter: drop-shadow(0 0 10px rgba(255, 255, 255, 0.3));
        }

        .header-logo img:hover {
            transform: scale(1.1);
            transition: transform 0.3s ease;
        }

        .header-logo img:active {
            transform: scale(1);
            transition: none;
        }

        /* Full View Popup for Posters */
        .popup-overlay {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.95);
            z-index: 10000;
            align-items: center;
            justify-content: center;
            backdrop-filter: blur(10px);
            overflow-y: auto;
            padding: 40px 20px;
        }

        .popup-overlay.active {
            display: flex;
        }

        .popup-content {
            position: relative;
            max-width: 1400px;
            width: 100%;
            animation: popupFadeIn 0.3s ease;
        }

        @keyframes popupFadeIn {
            from {
                opacity: 0;
                transform: scale(0.9);
            }
            to {
                opacity: 1;
                transform: scale(1);
            }
        }

        .popup-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 30px;
            margin-top: 60px;
        }

        .popup-poster {
            background: rgba(255, 255, 255, 0.95);
            border: 3px solid #ffffff;
            border-radius: 10px;
            padding: 15px;
            box-shadow: 0 15px 50px rgba(0, 0, 0, 0.8);
            transition: transform 0.3s ease;
            position: relative;
            cursor: pointer;
        }

        .popup-poster:hover {
            transform: scale(1.05);
        }

        .popup-poster img {
            width: 100%;
            height: auto;
            display: block;
            border-radius: 5px;
        }

        .popup-poster a {
            display: block;
            text-decoration: none;
            color: inherit;
        }

        /* Individual Poster Full View Popup */
        .poster-popup-overlay {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.95);
            z-index: 10000;
            align-items: center;
            justify-content: center;
            backdrop-filter: blur(10px);
            overflow-y: auto;
            padding: 40px 20px;
        }

        @media (max-width: 768px) {
            .poster-popup-overlay {
                padding: 20px 10px;
            }
        }

        @media (max-width: 480px) {
            .poster-popup-overlay {
                padding: 10px 5px;
            }
        }

        .poster-popup-overlay.active {
            display: flex;
        }

        .poster-popup-content {
            position: relative;
            max-width: 95%;
            width: 1100px;
            max-height: 90vh;
            overflow: hidden;
            background: rgba(255, 255, 255, 0.98);
            border: 3px solid #ffffff;
            border-radius: 20px;
            padding: 0;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.8);
            animation: popupFadeIn 0.3s ease;
            margin: auto;
            display: flex;
            flex-direction: row;
        }
        
        /* Make modals smaller on very large screens */
        @media (min-width: 1600px) {
            .poster-popup-content {
                width: 1000px;
                max-width: 70%;
            }
        }
        
        @media (min-width: 1920px) {
            .poster-popup-content {
                width: 900px;
                max-width: 60%;
            }
        }

        .poster-popup-image {
            width: 60%;
            height: 100%;
            max-height: 90vh;
            object-fit: cover;
            display: block;
            border-radius: 17px 0 0 17px;
            opacity: 0;
            transition: opacity 0.3s ease;
        }
        
        .poster-popup-image.loaded {
            opacity: 1;
        }
        
        .poster-popup-image.loading {
            opacity: 0;
            background: rgba(0, 0, 0, 0.1);
        }
        
        /* Loading spinner for modal images */
        .poster-popup-loading {
            position: absolute;
            top: 50%;
            left: 30%;
            transform: translate(-50%, -50%);
            width: 50px;
            height: 50px;
            border: 4px solid rgba(0, 0, 0, 0.1);
            border-top-color: #000000;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            z-index: 1;
        }
        
        @keyframes spin {
            to { transform: translate(-50%, -50%) rotate(360deg); }
        }
        
        .poster-popup-content.full-width-image .poster-popup-loading {
            left: 50%;
        }

        /* Full width image mode (for team_card4) */
        .poster-popup-content.full-width-image {
            width: auto;
            max-width: 85%;
            max-height: 90vh;
            padding: 0;
            border: none;
            background: transparent;
            box-shadow: none;
            border-radius: 0;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .poster-popup-content.full-width-image .poster-popup-image {
            width: auto;
            height: auto;
            max-width: 85vw;
            max-height: 90vh;
            object-fit: contain;
            border-radius: 0;
            display: block;
        }
        
        /* Make full-width-image modals smaller on very large screens */
        @media (min-width: 1600px) {
            .poster-popup-content.full-width-image {
                max-width: 70%;
            }
            
            .poster-popup-content.full-width-image .poster-popup-image {
                max-width: 70vw;
            }
        }
        
        @media (min-width: 1920px) {
            .poster-popup-content.full-width-image {
                max-width: 60%;
            }
            
            .poster-popup-content.full-width-image .poster-popup-image {
                max-width: 60vw;
            }
        }

        .poster-popup-info {
            width: 40%;
            padding: 60px 50px;
            background: linear-gradient(135deg, rgba(255, 255, 255, 0.98) 0%, rgba(250, 250, 250, 0.98) 100%);
            border-radius: 0 17px 17px 0;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: flex-start;
            overflow-y: auto;
            max-height: 95vh;
        }

        /* Hide info panel for full-width image mode */
        .poster-popup-content.full-width-image .poster-popup-info {
            display: none;
        }

        .poster-popup-header {
            display: flex;
            flex-direction: row;
            align-items: center;
            justify-content: flex-start;
            gap: 25px;
            margin-bottom: 30px;
            width: 100%;
            flex-wrap: wrap;
        }

        .poster-popup-name {
            font-size: 4rem;
            text-transform: uppercase;
            letter-spacing: 5px;
            color: #000000;
            margin: 0;
            font-weight: bold;
            line-height: 1.2;
        }
        
        /* Responsive name sizing */
        @media (max-width: 1600px) {
            .poster-popup-name {
                font-size: 3.5rem;
                letter-spacing: 4px;
            }
        }
        
        @media (max-width: 1400px) {
            .poster-popup-name {
                font-size: 3rem;
                letter-spacing: 3px;
            }
        }

        .poster-popup-link {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            text-decoration: none;
            transition: all 0.3s ease;
            padding: 12px 20px;
            background: rgba(0, 0, 0, 0.05);
            border-radius: 50px;
            gap: 12px;
        }

        .poster-popup-link:hover {
            transform: scale(1.05);
            background: rgba(0, 102, 204, 0.1);
        }

        .poster-popup-link.empty {
            display: none;
        }

        .poster-popup-link .x-logo {
            width: 32px;
            height: 32px;
            fill: #000000;
            transition: fill 0.3s ease;
        }
        
        /* Responsive X logo sizing */
        @media (max-width: 1600px) {
            .poster-popup-link .x-logo {
                width: 28px;
                height: 28px;
            }
        }
        
        @media (max-width: 1400px) {
            .poster-popup-link .x-logo {
                width: 26px;
                height: 26px;
            }
        }
        
        @media (max-width: 1200px) {
            .poster-popup-link {
                padding: 10px 16px;
            }
            
            .poster-popup-link .x-logo {
                width: 24px;
                height: 24px;
            }
        }

        .poster-popup-link:hover .x-logo {
            fill: #0066cc;
        }

        /* Team member list styling for team_card2 */
        .team-members-list {
            display: flex;
            flex-direction: column;
            gap: 25px;
            align-items: flex-start;
            width: 100%;
            margin-top: 20px;
        }

        .team-member-item {
            display: flex;
            flex-direction: row;
            align-items: center;
            justify-content: space-between;
            gap: 20px;
            padding: 0;
            width: 100%;
        }

        .team-member-name {
            font-size: 3.5rem;
            text-transform: uppercase;
            letter-spacing: 4px;
            color: #000000;
            font-weight: bold;
            line-height: 1.2;
            margin: 0;
        }

        .team-member-x-link {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            padding: 12px 20px;
            background: rgba(0, 0, 0, 0.05);
            border-radius: 50px;
            text-decoration: none;
            transition: all 0.3s ease;
            gap: 12px;
        }

        .team-member-x-link:hover {
            background: rgba(0, 102, 204, 0.1);
            transform: scale(1.05);
        }

        .team-member-x-link .x-logo {
            width: 32px;
            height: 32px;
            fill: #000000;
            transition: fill 0.3s ease;
        }

        .team-member-x-link:hover .x-logo {
            fill: #0066cc;
        }

        .poster-popup-designation {
            font-size: 1.3rem;
            text-align: center;
            color: #666666;
            margin-bottom: 15px;
            font-weight: 500;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .poster-popup-description {
            font-size: 1.1rem;
            text-align: center;
            color: #333333;
            line-height: 1.6;
            margin-bottom: 0;
        }

        .poster-popup-close {
            position: absolute;
            top: 15px;
            right: 15px;
            background: rgba(0, 0, 0, 0.2);
            border: 2px solid rgba(0, 0, 0, 0.3);
            color: #000000;
            width: 40px;
            height: 40px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            font-size: 24px;
            transition: all 0.3s ease;
            font-family: 'Finger Paint', sans-serif;
        }

        .poster-popup-close:hover {
            background: rgba(0, 0, 0, 0.3);
            transform: rotate(90deg) scale(1.1);
        }

        .popup-header {
            text-align: center;
            margin-bottom: 30px;
        }

        .popup-header h2 {
            font-size: 3rem;
            text-transform: uppercase;
            letter-spacing: 4px;
            text-shadow: 0 0 20px rgba(255, 255, 255, 0.5);
        }

        .popup-close {
            position: fixed;
            top: 30px;
            right: 30px;
            background: rgba(255, 255, 255, 0.2);
            border: 2px solid rgba(255, 255, 255, 0.3);
            color: #ffffff;
            width: 50px;
            height: 50px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            font-size: 28px;
            transition: all 0.3s ease;
            font-family: 'Finger Paint', sans-serif;
            z-index: 10001;
        }

        .popup-close:hover {
            background: rgba(255, 255, 255, 0.3);
            transform: rotate(90deg) scale(1.1);
        }

        .container {
            width: 100%;
            max-width: 100%;
            margin: 0 auto;
            padding: 0 20px;
            position: relative;
            overflow: visible;
        }

        @keyframes pulse {
            0%, 100% {
                opacity: 0.7;
            }
            50% {
                opacity: 1;
            }
        }


        .posters-container {
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            align-items: flex-start;
            gap: 30px;
            width: 100%;
            max-width: 100%;
            margin: 0 auto;
            padding: 40px 20px;
            position: relative;
            overflow: visible;
        }

        .poster {
            position: relative;
            transition: transform 0.3s ease;
            cursor: pointer;
            flex: 0 0 auto;
            /* No border, no background - just the card image */
            border: none;
            background: transparent;
            box-shadow: none;
            transform-origin: center center;
        }

        .poster:hover {
            z-index: 100;
            transform: scale(1.05) rotate(var(--card-rotation, 0deg));
        }

        /* Card name and X logo overlay */
        .card-overlay {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            align-items: center;
            gap: 15px;
            z-index: 10;
            pointer-events: none;
        }

        .card-name {
            font-family: 'Finger Paint', sans-serif;
            font-size: 1.5rem;
            color: #ffffff;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.8);
            font-weight: bold;
            text-transform: uppercase;
            letter-spacing: 2px;
        }

        .card-x-link {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            width: 32px;
            height: 32px;
            background: rgba(255, 255, 255, 0.9);
            border-radius: 50%;
            text-decoration: none;
            transition: all 0.3s ease;
            pointer-events: auto;
            cursor: pointer;
        }

        .card-x-link:hover {
            background: rgba(255, 255, 255, 1);
            transform: scale(1.1);
        }

        .card-x-link .x-logo {
            width: 20px;
            height: 20px;
            fill: #000000;
        }

        .card-x-link:hover .x-logo {
            fill: #0066cc;
        }

        .poster img {
            width: 100%;
            height: auto;
            display: block;
                max-width: 100%;
        }
        
        /* Responsive card sizing - cards wrap naturally like gallery */
        @media (min-width: 1400px) {
            .poster {
                width: calc((100% - 90px) / 4); /* 4 cards per row with gaps */
                max-width: 416px;
            }
        }
        
        @media (min-width: 1024px) and (max-width: 1399px) {
            .poster {
                width: calc((100% - 60px) / 3); /* 3 cards per row */
                max-width: 400px;
            }
        }
        
        @media (min-width: 768px) and (max-width: 1023px) {
            .poster {
                width: calc((100% - 30px) / 2); /* 2 cards per row */
                max-width: 350px;
            }
        }
        
        @media (max-width: 767px) {
            .poster {
                width: 100%;
                max-width: 320px;
            }
            
            .posters-container {
                gap: 40px;
            }
        }
        
        @media (max-width: 480px) {
            .poster {
                max-width: 280px;
            }
        }

        /* Responsive Design */
        @media (max-width: 1200px) {
            .poster-popup-content {
                width: 95%;
                max-width: 900px;
            }

            .poster-popup-content.full-width-image {
                width: auto;
                max-width: 85%;
                max-height: 90vh;
                padding: 0;
                border: none;
                background: transparent;
                box-shadow: none;
                border-radius: 0;
            }

            .poster-popup-image {
                width: 55%;
            }
            
            .poster-popup-content.full-width-image .poster-popup-image {
                width: auto;
                height: auto;
                max-width: 85vw;
                max-height: 90vh;
                object-fit: contain;
                border-radius: 0;
            }

            .poster-popup-info {
                width: 45%;
                padding: 40px 30px;
            }

            .poster-popup-name {
                font-size: 3rem;
                letter-spacing: 4px;
            }

            .team-member-name {
                font-size: 2.8rem;
            }
        }

        @media (max-width: 1200px) {
            .popup-grid {
                grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
                gap: 25px;
            }
        }

        @media (max-width: 768px) {
            .header-logo {
                top: 15px;
                left: 15px;
            }

            .header-logo img {
                max-width: 100px;
            }

            .popup-overlay {
                padding: 60px 15px 20px;
            }

            .popup-header h2 {
                font-size: 2rem;
            }

            .popup-grid {
                grid-template-columns: 1fr;
                gap: 20px;
                margin-top: 30px;
            }

            .popup-close {
                top: 15px;
                right: 15px;
                width: 45px;
                height: 45px;
                font-size: 24px;
            }

            .poster-popup-content {
                flex-direction: column;
                max-width: 95%;
                width: 90%;
                max-height: 90vh;
            }

            .poster-popup-content.full-width-image {
                flex-direction: column;
                width: auto;
                max-width: 95%;
                max-height: 95vh;
                padding: 0;
                border: none;
                background: transparent;
                box-shadow: none;
                border-radius: 0;
            }

            .poster-popup-image {
                width: 100%;
                height: auto;
                max-height: 50vh;
                border-radius: 17px 17px 0 0;
            }
            
            .poster-popup-loading {
                left: 50%;
            }

            .poster-popup-content.full-width-image .poster-popup-image {
                width: auto;
                height: auto;
                max-width: 95vw;
                max-height: 90vh;
                object-fit: contain;
                border-radius: 0;
            }
            
            .poster-popup-content.full-width-image .poster-popup-loading {
                left: 50%;
            }

            .poster-popup-info {
                width: 100%;
                padding: 30px 20px;
                border-radius: 0 0 17px 17px;
                max-height: 50vh;
                overflow-y: auto;
            }

            .poster-popup-header {
                flex-direction: row;
                align-items: center;
                gap: 20px;
            }

            .poster-popup-name {
                font-size: 2.5rem;
                letter-spacing: 3px;
            }
            
            .poster-popup-link {
                padding: 10px 16px;
            }

            .team-member-item {
                flex-direction: row;
                align-items: center;
                justify-content: space-between;
                gap: 15px;
            }

            .team-member-name {
                font-size: 2rem;
                margin: 0;
            }

            .team-member-x-link {
                padding: 10px 16px;
                flex-shrink: 0;
            }

            .team-member-x-link .x-logo {
                width: 24px;
                height: 24px;
            }

            .poster-popup-link .x-logo {
                width: 24px;
                height: 24px;
            }

            .poster-popup-designation {
                font-size: 1.1rem;
            }

            .poster-popup-description {
                font-size: 0.95rem;
            }

            .story-poster {
                padding: 25px 20px;
            }

            .story-poster h2 {
                font-size: 1.8rem;
            }

            .story-poster p {
                font-size: 0.95rem;
            }

            .story-poster .click-hint {
                font-size: 0.9rem;
            }
        }

        @media (max-width: 480px) {
            .container {
                padding: 90px 15px 15px;
            }

            .story-poster {
                padding: 25px 15px;
            }

            .story-poster h2 {
                font-size: 1.5rem;
            }

            .story-poster p {
                font-size: 0.9rem;
            }

            .story-poster .click-hint {
                font-size: 0.85rem;
            }

            .poster-popup-content {
                flex-direction: column;
                max-width: 98%;
                width: 95%;
            }

            .poster-popup-content.full-width-image {
                width: auto;
                max-width: 98%;
                max-height: 95vh;
                padding: 0;
                border: none;
                background: transparent;
                box-shadow: none;
                border-radius: 0;
            }

            .poster-popup-image {
                width: 100%;
                max-height: 40vh;
            }

            .poster-popup-content.full-width-image .poster-popup-image {
                width: auto;
                height: auto;
                max-width: 98vw;
                max-height: 90vh;
                object-fit: contain;
                border-radius: 0;
            }

            .poster-popup-info {
                width: 100%;
                padding: 20px 15px;
                max-height: 60vh;
            }

            .poster-popup-header {
                flex-direction: row;
                align-items: center;
                gap: 15px;
            }

            .poster-popup-name {
                font-size: 1.8rem;
                letter-spacing: 2px;
            }
            
            .poster-popup-link {
                padding: 8px 14px;
            }
            
            .poster-popup-link .x-logo {
                width: 20px;
                height: 20px;
            }

            .team-member-item {
                flex-direction: row;
                align-items: center;
                justify-content: space-between;
                gap: 12px;
            }

            .team-member-name {
                font-size: 1.5rem;
                margin: 0;
            }

            .team-member-x-link {
                padding: 8px 14px;
                flex-shrink: 0;
            }

            .team-member-x-link .x-logo {
                width: 20px;
                height: 20px;
            }

            .poster-popup-link {
                padding: 10px 16px;
            }

            .poster-popup-link .x-logo {
                width: 20px;
                height: 20px;
            }

            .poster-popup-designation {
                font-size: 1rem;
                margin-bottom: 12px;
            }

            .poster-popup-description {
                font-size: 0.9rem;
            }

            .header-logo img {
                max-width: 80px;
            }

            .popup-header h2 {
                font-size: 1.5rem;
            }
        }

        /* Animation on load */
        @keyframes fadeInUp {
            from {
                opacity: 0;
                transform: translateY(30px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        @keyframes posterAppear {
            from {
                opacity: 0;
                transform: scale(0.8) rotate(0deg);
            }
            to {
                opacity: 1;
            }
        }

        .poster {
            animation: posterAppear 0.8s ease forwards;
        }

        .poster-1 { animation-delay: 0.2s; }
        .poster-2 { animation-delay: 0.4s; }
        .poster-3 { animation-delay: 0.6s; }
        .poster-4 { animation-delay: 0.8s; }
    </style>
</head>
<body class="loading">
    <!-- Loading Screen -->
    <div class="loading-screen" id="loadingScreen">
        <div class="loading-screen-content">
            <div class="loading-percentage" id="loadingPercentage">0</div>
        </div>
    </div>
    <div class="header-logo">
        <img src="assets/main_logo.png" alt="The Prometheans Logo" id="header-logo-img">
    </div>

    <!-- Full View Popup for All Posters (THE TEAM) -->
    <div class="popup-overlay" id="posters-popup">
        <div class="popup-close" id="popup-close">×</div>
        <div class="popup-content">
            <div class="popup-header">
                <h2>THE TEAM</h2>
            </div>
            <div class="popup-grid">
                <div class="popup-poster" data-team="team_card1">
                    <img src="assets/team_card1.png" alt="Team Card 1" onerror="this.style.display='none'">
                </div>
                <div class="popup-poster" data-team="team_card2">
                    <img src="assets/team_card2.png" alt="Team Card 2" onerror="this.style.display='none'">
                </div>
                <div class="popup-poster" data-team="team_card3">
                    <img src="assets/team_card3.png" alt="Team Card 3" onerror="this.style.display='none'">
                </div>
                <div class="popup-poster" data-team="team_card4">
                    <img src="assets/team_card4.png" alt="Team Card 4" onerror="this.style.display='none'">
                </div>
            </div>
        </div>
    </div>

    <!-- Individual Poster Full View Popup -->
    <div class="poster-popup-overlay" id="poster-popup">
        <div class="poster-popup-close" id="poster-popup-close">×</div>
        <div class="poster-popup-content">
            <img id="poster-popup-image" class="poster-popup-image" src="" alt="Team Member">
            <div class="poster-popup-info">
            <div class="poster-popup-header">
                <h3 id="poster-popup-name" class="poster-popup-name"></h3>
                <a id="poster-popup-link" class="poster-popup-link" href="#" target="_blank" rel="noopener noreferrer">
                    <svg class="x-logo" viewBox="0 0 24 24" fill="currentColor">
                        <path d="M18.244 2.25h3.308l-7.227 8.26 8.502 11.24H16.17l-5.214-6.817L4.99 21.75H1.68l7.73-8.835L1.254 2.25H8.08l4.713 6.231zm-1.161 17.52h1.833L7.084 4.126H5.117z"/>
                    </svg>
                </a>
            </div>
                <div id="poster-popup-members" class="team-members-list" style="display: none;"></div>
            <div id="poster-popup-designation" class="poster-popup-designation"></div>
            <p id="poster-popup-description" class="poster-popup-description"></p>
        </div>
    </div>
        </div>

    <div class="page-wrapper">
    <div class="container">
            <!-- Team Cards with Random Angles -->
        <div class="posters-container">
            <div class="poster poster-1" id="poster-1">
                    <img src="assets/team_card1.png" alt="Team Card 1" onerror="this.style.display='none'">
            </div>
            <div class="poster poster-2" id="poster-2">
                    <img src="assets/team_card2.png" alt="Team Card 2" onerror="this.style.display='none'">
            </div>
            <div class="poster poster-3" id="poster-3">
                    <img src="assets/team_card3.png" alt="Team Card 3" onerror="this.style.display='none'">
            </div>
            <div class="poster poster-4" id="poster-4">
                    <img src="assets/team_card4.png" alt="Team Card 4" onerror="this.style.display='none'">
                </div>
            </div>
        </div>
    </div>

    <!-- Canvas container for PIXI.js instruction animation -->
    <div id="instruction-canvas-container" style="position: fixed; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; z-index: 9999; display: none;"></div>

    <script src="libs/pixi.js"></script>
    <script>
        // Wait for all fonts to load properly
        async function waitForFonts() {
            try {
                // Wait for document.fonts API to be ready
                if (!document.fonts || !document.fonts.ready) {
                    console.warn('Font API not available, proceeding without font check');
                    return;
                }

                // Wait for fonts.ready with a reasonable timeout
                await Promise.race([
                    document.fonts.ready,
                    new Promise(resolve => setTimeout(resolve, 3000)) // 3 second timeout
                ]);

                // Helper function to check font with multiple variations
                function checkFont(fontFamily) {
                    return document.fonts.check(`1em "${fontFamily}"`) ||
                           document.fonts.check(`1em ${fontFamily}`) ||
                           document.fonts.check(`12px "${fontFamily}"`) ||
                           document.fonts.check(`12px ${fontFamily}`);
                }

                // Check if both fonts are loaded
                let fingerPaintLoaded = checkFont('Finger Paint');
                let digitalLoaded = checkFont('Digital');

                // Wait a bit more if fonts aren't loaded yet (with timeout)
                let attempts = 0;
                const maxAttempts = 30; // 3 seconds total (30 * 100ms)

                while ((!fingerPaintLoaded || !digitalLoaded) && attempts < maxAttempts) {
                    await new Promise(resolve => setTimeout(resolve, 100));
                    fingerPaintLoaded = checkFont('Finger Paint');
                    digitalLoaded = checkFont('Digital');

                    if (fingerPaintLoaded && digitalLoaded) {
                        console.log('All fonts loaded successfully');
                        return;
                    }
                    attempts++;
                }

                // Final check and log
                fingerPaintLoaded = checkFont('Finger Paint');
                digitalLoaded = checkFont('Digital');

                if (fingerPaintLoaded) {
                    console.log('✓ Finger Paint font loaded');
                } else {
                    console.warn('✗ Finger Paint font not loaded, using fallback');
                }

                if (digitalLoaded) {
                    console.log('✓ Digital font loaded');
                } else {
                    console.warn('✗ Digital font not loaded, using fallback');
                }

            } catch (error) {
                console.warn('Error waiting for fonts:', error);
                // Continue anyway - fallback fonts will be used
            }
        }

        // Loading Screen Functionality
        async function initLoadingScreen() {
            // Wait for all fonts to load properly before proceeding
            await waitForFonts();
            
            const loadingScreen = document.getElementById('loadingScreen');
            const loadingPercentage = document.getElementById('loadingPercentage');
            if (!loadingScreen) return;

            let currentPercentage = 0;
            let animationFrameId = null;
            let loadingComplete = false;
            const startTime = Date.now();
            const minLoadingTime = 2500; // Minimum 2.5 seconds for smooth animation
            let allContentLoaded = false;
            let imageLoadProgress = 0; // Track image loading progress (0-1)
            
            let isRolling = false;
            let rollInterval = null;
            let currentRollValue = 1;
            const rollSpeed = 15; // Milliseconds between number changes (much faster animation)

            // Continuous rolling animation from 1% to 100%
            function startRolling() {
                if (isRolling) return;
                
                isRolling = true;
                currentRollValue = 1;
                
                // Clear any existing roll interval
                if (rollInterval) {
                    clearInterval(rollInterval);
                }
                
                // Update initial value
                if (loadingPercentage) {
                    loadingPercentage.textContent = currentRollValue;
                }
                
                rollInterval = setInterval(() => {
                    // Increment the value
                    currentRollValue++;
                    
                    if (currentRollValue <= 100) {
                        // Update display with current rolling value
                        if (loadingPercentage) {
                            loadingPercentage.textContent = currentRollValue;
                        }
                    } else {
                        // Reached 100%
                        clearInterval(rollInterval);
                        rollInterval = null;
                        isRolling = false;
                        currentRollValue = 100;
                        
                        if (loadingPercentage) {
                            loadingPercentage.textContent = 100;
                        }
                        
                        // Trigger completion check
                        checkForCompletion();
                    }
                }, rollSpeed);
            }
            
            // Check if loading is complete and trigger hide
            function checkForCompletion() {
                const elapsed = Date.now() - startTime;
                const minTimeElapsed = elapsed >= minLoadingTime;
                
                if (currentRollValue >= 100 && !loadingComplete && minTimeElapsed) {
                    loadingComplete = true;
                    onLoadingComplete();
                }
            }

            // Update percentage display
            function updatePercentage() {
                if (loadingPercentage) {
                    loadingPercentage.textContent = Math.min(100, Math.max(1, currentRollValue));
                }
            }

            // Animate percentage counter
            function animatePercentage() {
                // Check for completion
                checkForCompletion();
                
                // Stop animation if complete
                if (loadingComplete) {
                    if (animationFrameId) {
                        cancelAnimationFrame(animationFrameId);
                        animationFrameId = null;
                    }
                    return;
                }
                
                // Continue animation
                animationFrameId = requestAnimationFrame(animatePercentage);
            }

            // Called when loading reaches 100%
            function onLoadingComplete() {
                // Hide loading screen immediately
                hideLoadingScreen();
            }

            // Update image loading progress (0 to 1)
            function updateImageProgress(progress) {
                imageLoadProgress = Math.min(1, Math.max(0, progress));
            }

            // Mark content as fully loaded
            function markContentLoaded() {
                allContentLoaded = true;
                imageLoadProgress = 1; // Mark images as fully loaded
            }

            // Hide loading screen after page loads and content is ready
            function hideLoadingScreen() {
                // Ensure we show 100% before hiding
                if (currentRollValue < 100) {
                    currentRollValue = 100;
                    if (loadingPercentage) {
                        loadingPercentage.textContent = 100;
                    }
                    // Try again immediately
                    hideLoadingScreen();
                    return;
                }

                // Mark body as loaded to show content
                document.body.classList.remove('loading');
                document.body.classList.add('loaded');

                // Hide loading screen
                if (loadingScreen && !loadingScreen.classList.contains('hidden')) {
                    loadingScreen.classList.add('hidden');
                    // Remove from DOM after fade out completes
                    setTimeout(() => {
                        if (loadingScreen.parentNode) {
                            loadingScreen.parentNode.removeChild(loadingScreen);
                        }
                        if (animationFrameId) {
                            cancelAnimationFrame(animationFrameId);
                            animationFrameId = null;
                        }
                        // Re-enable scrolling
                        document.body.style.overflow = '';
                    }, 300);
                }
            }

            // Start animation - continuous roll from 1% to 100%
            currentRollValue = 1;
            updatePercentage();
            startRolling();
            animatePercentage();

            // Wait for images and content to load
            const images = document.querySelectorAll('img');
            const totalImages = images.length;
            let imagesLoaded = 0;

            if (totalImages === 0) {
                // No images, mark as loaded after minimum time
                setTimeout(() => {
                    markContentLoaded();
                }, minLoadingTime);
                return;
            }

            function checkAllLoaded() {
                imagesLoaded++;
                // Update image loading progress (0 to 1)
                const progress = imagesLoaded / totalImages;
                updateImageProgress(progress);
                
                if (imagesLoaded >= totalImages) {
                    // All images loaded, mark content as loaded
                    // Animation will continue to 100% naturally based on time
                    markContentLoaded();
                }
            }

            // Check if images are already loaded
            images.forEach(img => {
                if (img.complete) {
                    checkAllLoaded();
                } else {
                    img.addEventListener('load', checkAllLoaded);
                    img.addEventListener('error', checkAllLoaded); // Count errors too
                }
            });

            // Fallback: mark as loaded after maximum wait time (4 seconds)
            setTimeout(() => {
                markContentLoaded();
            }, 4000);
        }

        // Initialize loading screen when DOM is ready
        document.addEventListener('DOMContentLoaded', async () => {
            // Initialize loading screen (async to preload font)
            await initLoadingScreen();
        });

        // Team member data with links, designation, and description
        const teamData = {
            'team_card1': {
                name: 'DMITRI',
                fullViewImage: 'team_card1_full_view.png',
                designation: '',
                description: '',
                link: 'https://x.com/zabolotniyD',
                showOnCard: true
            },
            'team_card2': {
                name: 'NARM, ACRIS, DANIEL',
                fullViewImage: 'team_card2_full_view.png',
                designation: '',
                description: '',
                link: '',
                showOnCard: false,
                members: [
                    { name: 'NARM', link: 'https://x.com/PX_Narm' },
                    { name: 'ACRIS', link: 'https://x.com/itsmeacris' },
                    { name: 'DANIEL', link: 'https://x.com/daniarchibong_' }
                ]
            },
            'team_card3': {
                name: 'SANTOL',
                fullViewImage: 'team_card3_full_view.png',
                designation: '',
                description: '',
                link: 'https://x.com/PX_Santol',
                showOnCard: true
            },
            'team_card4': {
                name: '',
                fullViewImage: 'team_card4_full_view.png',
                designation: '',
                description: '',
                link: '',
                showOnCard: false
            }
        };
        
        // Preload all full view images for faster modal loading
        const preloadedImages = new Map();
        
        function preloadFullViewImages() {
            Object.keys(teamData).forEach(teamId => {
                const data = teamData[teamId];
                if (data.fullViewImage) {
                    const imageSrc = `assets/${data.fullViewImage}`;
                    const img = new Image();
                    img.src = imageSrc;
                    preloadedImages.set(teamId, img);
                    console.log(`Preloading image: ${imageSrc}`);
                }
            });
        }
        
        // Start preloading after page loads
        window.addEventListener('load', () => {
            // Wait a bit for initial page load to complete
            setTimeout(() => {
                preloadFullViewImages();
            }, 1000);
        });

        // Posters popup functionality
        const headerLogo = document.getElementById('header-logo-img');
        const postersPopup = document.getElementById('posters-popup');
        const popupClose = document.getElementById('popup-close');
        const allPosters = document.querySelectorAll('.poster');
        const posterPopup = document.getElementById('poster-popup');
        const posterPopupClose = document.getElementById('poster-popup-close');
        const posterPopupImage = document.getElementById('poster-popup-image');
        const posterPopupName = document.getElementById('poster-popup-name');
        const posterPopupLink = document.getElementById('poster-popup-link');
        const posterPopupMembers = document.getElementById('poster-popup-members');
        const posterPopupDesignation = document.getElementById('poster-popup-designation');
        const posterPopupDescription = document.getElementById('poster-popup-description');

        // Function to open THE TEAM popup
        function openTeamPopup() {
            postersPopup.classList.add('active');
            document.body.style.overflow = 'hidden';
        }

        // Function to open individual poster popup
        function openPosterPopup(teamId) {
            const data = teamData[teamId];
            const posterPopupContent = document.querySelector('.poster-popup-content');
            
            if (data) {
                // Show modal immediately
                posterPopup.classList.add('active');
                document.body.style.overflow = 'hidden';
                
                // Use full view image if available, otherwise use regular card
                const imageSrc = data.fullViewImage ? `assets/${data.fullViewImage}` : `assets/${teamId}.png`;
                
                // Remove existing loading spinner if any
                const existingSpinner = posterPopupContent.querySelector('.poster-popup-loading');
                if (existingSpinner) {
                    existingSpinner.remove();
                }
                
                // Check if image is already preloaded
                const preloadedImg = preloadedImages.get(teamId);
                
                // Reset image state
                posterPopupImage.classList.remove('loaded');
                posterPopupImage.classList.add('loading');
                posterPopupImage.style.opacity = '0';
                
                // Add loading spinner
                const loadingSpinner = document.createElement('div');
                loadingSpinner.className = 'poster-popup-loading';
                posterPopupContent.appendChild(loadingSpinner);
                
                // Function to show image when loaded
                const showImage = () => {
                    loadingSpinner.remove();
                    posterPopupImage.classList.remove('loading');
                    posterPopupImage.classList.add('loaded');
                    posterPopupImage.style.opacity = '1';
                };
                
                // If preloaded and already loaded, use it immediately
                if (preloadedImg && preloadedImg.complete && preloadedImg.naturalWidth > 0) {
                    posterPopupImage.src = imageSrc;
                    posterPopupImage.alt = data.name || 'Team Card';
                    // Image is already loaded, show immediately
                    setTimeout(showImage, 50);
                } else {
                    // Load image
                    posterPopupImage.src = imageSrc;
                    posterPopupImage.alt = data.name || 'Team Card';
                    
                    // Wait for image to load
                    if (posterPopupImage.complete && posterPopupImage.naturalWidth > 0) {
                        // Already loaded
                        showImage();
                    } else {
                        // Wait for load event
                        posterPopupImage.onload = () => {
                            showImage();
                        };
                        posterPopupImage.onerror = () => {
                            loadingSpinner.remove();
                            console.error('Failed to load image:', imageSrc);
                        };
                    }
                }

                // For team_card4, show only full image (no info panel)
                if (teamId === 'team_card4') {
                    posterPopupContent.classList.add('full-width-image');
                    // Hide all info elements
                    posterPopupName.style.display = 'none';
                    posterPopupLink.style.display = 'none';
                    posterPopupMembers.style.display = 'none';
                    posterPopupDesignation.style.display = 'none';
                    posterPopupDescription.style.display = 'none';
                } else {
                    // Remove full-width class for other cards
                    posterPopupContent.classList.remove('full-width-image');
                    
                    // Hide members list by default
                    posterPopupMembers.style.display = 'none';
                    posterPopupMembers.innerHTML = '';
                    
                    // For team_card2, show multiple members in a dedicated area
                    if (teamId === 'team_card2' && data.members) {
                    // Hide single name/link header
                    posterPopupName.style.display = 'none';
                    posterPopupLink.style.display = 'none';
                    
                    // Show members list
                    posterPopupMembers.style.display = 'flex';
                    data.members.forEach(member => {
                        const memberItem = document.createElement('div');
                        memberItem.className = 'team-member-item';
                        
                        const memberName = document.createElement('span');
                        memberName.className = 'team-member-name';
                        memberName.textContent = member.name;
                        
                        const memberXLink = document.createElement('a');
                        memberXLink.className = 'team-member-x-link';
                        memberXLink.href = member.link;
                        memberXLink.target = '_blank';
                        memberXLink.rel = 'noopener noreferrer';
                        
                        const xLogoSvg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
                        xLogoSvg.setAttribute('class', 'x-logo');
                        xLogoSvg.setAttribute('viewBox', '0 0 24 24');
                        xLogoSvg.setAttribute('fill', 'currentColor');
                        const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                        path.setAttribute('d', 'M18.244 2.25h3.308l-7.227 8.26 8.502 11.24H16.17l-5.214-6.817L4.99 21.75H1.68l7.73-8.835L1.254 2.25H8.08l4.713 6.231zm-1.161 17.52h1.833L7.084 4.126H5.117z');
                        xLogoSvg.appendChild(path);
                        memberXLink.appendChild(xLogoSvg);
                        
                        memberItem.appendChild(memberName);
                        memberItem.appendChild(memberXLink);
                        posterPopupMembers.appendChild(memberItem);
                    });
                } else {
                    // Show single name/link header for other cards
                    posterPopupMembers.style.display = 'none';

                // Set name
                if (data.name) {
                    posterPopupName.textContent = data.name;
                    posterPopupName.style.display = 'block';
                } else {
                    posterPopupName.style.display = 'none';
                    }

                    // Set link
                    if (data.link) {
                        posterPopupLink.href = data.link;
                        posterPopupLink.classList.remove('empty');
                        posterPopupLink.style.display = 'inline-flex';
                    } else {
                        posterPopupLink.href = '#';
                        posterPopupLink.classList.add('empty');
                        posterPopupLink.style.display = 'none';
                    }
                    }
                }

                // Set designation
                if (data.designation) {
                    posterPopupDesignation.textContent = data.designation;
                    posterPopupDesignation.style.display = 'block';
                } else {
                    posterPopupDesignation.style.display = 'none';
                }

                // Set description
                if (data.description) {
                    posterPopupDescription.textContent = data.description;
                    posterPopupDescription.style.display = 'block';
                } else {
                    posterPopupDescription.style.display = 'none';
                }
            }
        }

        // Remove story poster functionality (no longer exists)

        // Header logo click - redirects to homepage
        headerLogo.addEventListener('click', () => {
            window.location.href = '/';
        });

        // Individual posters click - opens individual popup
        allPosters.forEach(poster => {
            poster.addEventListener('click', () => {
                const posterId = poster.id;
                // Extract team card from poster ID (poster-1 -> team_card1)
                const teamId = posterId.replace('poster-', 'team_card');
                openPosterPopup(teamId);
            });
        });

        // Make THE TEAM popup cards clickable for full view
        const popupPosters = document.querySelectorAll('.popup-poster');
        popupPosters.forEach(poster => {
            poster.addEventListener('click', (e) => {
                e.preventDefault();
                e.stopPropagation();
                const teamId = poster.getAttribute('data-team');
                if (teamId) {
                    // Close THE TEAM popup first
                    postersPopup.classList.remove('active');
                    // Open individual poster popup
                    openPosterPopup(teamId);
                }
            });
        });

        // Close popup
        popupClose.addEventListener('click', () => {
            postersPopup.classList.remove('active');
            document.body.style.overflow = '';
        });

        postersPopup.addEventListener('click', (e) => {
            if (e.target === postersPopup) {
                postersPopup.classList.remove('active');
                document.body.style.overflow = '';
            }
        });

        // Close individual poster popup
        posterPopupClose.addEventListener('click', () => {
            posterPopup.classList.remove('active');
            document.body.style.overflow = '';
        });

        posterPopup.addEventListener('click', (e) => {
            if (e.target === posterPopup) {
                posterPopup.classList.remove('active');
                document.body.style.overflow = '';
            }
        });

        // Close popup on Escape key
        document.addEventListener('keydown', (e) => {
            if (e.key === 'Escape') {
                if (postersPopup.classList.contains('active')) {
                    postersPopup.classList.remove('active');
                    document.body.style.overflow = '';
                }
                if (posterPopup.classList.contains('active')) {
                    posterPopup.classList.remove('active');
                    document.body.style.overflow = '';
                }
            }
        });

        // Position cards at random angles and positions within 1920x1080 area
        const cards = document.querySelectorAll('.poster');
        let containerWidth = 1920;
        let containerHeight = 1080;
        let edgePadding = 100; // Spacing from edges (100px on each side)
        
        // Store positioned cards to avoid overlap - DECLARE BEFORE USE
        const positionedCards = [];
        const cardData = [];
        
        // Adjust for mobile/tablet sizes
        const isMobile = window.innerWidth <= 768;
        const isTablet = window.innerWidth > 768 && window.innerWidth <= 1024;
        
        // IMPORTANT: Always use 1920x1080 for positioning calculations
        // The page-wrapper is fixed at 1920x1080 and scales via CSS transform
        // Extend height when screen is smaller to allow vertical scrolling as cards move down
        containerWidth = 1920;
        const screenWidth = window.innerWidth;
        const needsExtendedHeight = screenWidth < 1920; // Any screen smaller than desktop
        containerHeight = needsExtendedHeight ? 1500 : 1080; // Extended height for vertical scrolling
        
        if (isMobile) {
            edgePadding = 50;
        } else if (isTablet) {
            edgePadding = 75;
        }
        
        // ============================================
        // CARD ANGLE ADJUSTMENTS - Easy to modify
        // ============================================
        // Set fixed rotation angles for each card (in degrees)
        // Positive = clockwise, Negative = counter-clockwise
        // Desktop angles (matching 1st image)
        // No rotations - cards are simple boxes for clear responsive grid visualization
        const cardAnglesDesktop = {
            'team_card1': 0,   // No rotation - simple box
            'team_card2': 0,   // No rotation - simple box
            'team_card3': 0,   // No rotation - simple box
            'team_card4': 0    // No rotation - simple box
        };
        
        const cardAnglesMobile = {
            'team_card1': 0,   // No rotation
            'team_card2': 0,   // No rotation
            'team_card3': 0,   // No rotation
            'team_card4': 0    // No rotation
        };
        
        // Use appropriate angles based on screen size
        const cardAngles = isMobile ? cardAnglesMobile : cardAnglesDesktop;
        
        // Get fixed angles for each card
        const cardIds = ['team_card1', 'team_card2', 'team_card3', 'team_card4'];
        const fixedAngles = cardIds.map(id => cardAngles[id] || 0);
        
        // Initialize paper flip sound for team card hover
        let teamCardPaperFlipSound = null;
        let isAudioUnlocked = false; // Track if audio has been unlocked by user interaction
        
        try {
            teamCardPaperFlipSound = new Audio('assets/sounds/paper_flip.mp3');
            teamCardPaperFlipSound.volume = 0.6; // Set volume (60%)
            teamCardPaperFlipSound.preload = 'auto';
            teamCardPaperFlipSound.addEventListener('error', (e) => {
                console.warn('Failed to load paper_flip.mp3:', e);
                teamCardPaperFlipSound = null;
            });
        } catch (error) {
            console.warn('Failed to create paper flip sound:', error);
            teamCardPaperFlipSound = null;
        }
        
        // Unlock audio on first user interaction
        function unlockAudio() {
            if (!isAudioUnlocked && teamCardPaperFlipSound) {
                // Play and immediately pause to unlock audio
                const playPromise = teamCardPaperFlipSound.play();
                if (playPromise !== undefined) {
                    playPromise.then(() => {
                        teamCardPaperFlipSound.pause();
                        teamCardPaperFlipSound.currentTime = 0;
                        isAudioUnlocked = true;
                    }).catch(() => {
                        // Ignore errors - audio will unlock on next interaction
                    });
                } else {
                    // Some browsers return undefined, try direct play
                    try {
                        teamCardPaperFlipSound.play();
                        teamCardPaperFlipSound.pause();
                        teamCardPaperFlipSound.currentTime = 0;
                        isAudioUnlocked = true;
                    } catch (e) {
                        // Ignore
                    }
                }
            }
        }
        
        // Aggressively unlock audio on ANY user interaction with the page
        // This includes mouse movement, clicks, touches, keypresses, etc.
        const unlockOnInteraction = () => {
            unlockAudio();
        };
        
        // Try to unlock on various interactions - use capture phase to catch early
        document.addEventListener('mousedown', unlockOnInteraction, { once: true, capture: true });
        document.addEventListener('mouseup', unlockOnInteraction, { once: true, capture: true });
        document.addEventListener('click', unlockOnInteraction, { once: true, capture: true });
        document.addEventListener('touchstart', unlockOnInteraction, { once: true, capture: true });
        document.addEventListener('touchend', unlockOnInteraction, { once: true, capture: true });
        document.addEventListener('keydown', unlockOnInteraction, { once: true, capture: true });
        
        // Also unlock on pointerdown (works for both mouse and touch)
        document.addEventListener('pointerdown', unlockOnInteraction, { once: true, capture: true });
        
        // Also try on first mouse movement (some browsers allow this)
        // Use capture phase and make it more aggressive
        let mouseMoveAttempted = false;
        document.addEventListener('mousemove', () => {
            if (!mouseMoveAttempted && !isAudioUnlocked) {
                mouseMoveAttempted = true;
                unlockAudio();
            }
        }, { once: true, capture: true, passive: true });
        
        // Also try on pointermove (works for both mouse and touch)
        let pointerMoveAttempted = false;
        document.addEventListener('pointermove', () => {
            if (!pointerMoveAttempted && !isAudioUnlocked) {
                pointerMoveAttempted = true;
                unlockAudio();
            }
        }, { once: true, capture: true, passive: true });
        
        // Try to unlock audio once page is fully loaded and interactive
        // This helps unlock audio before first hover
        window.addEventListener('load', () => {
            // Wait a bit for everything to be ready
            setTimeout(() => {
                if (!isAudioUnlocked && teamCardPaperFlipSound) {
                    // Try to unlock by playing and pausing silently
                    teamCardPaperFlipSound.play().then(() => {
                        teamCardPaperFlipSound.pause();
                        teamCardPaperFlipSound.currentTime = 0;
                        isAudioUnlocked = true;
                    }).catch(() => {
                        // Will unlock on first user interaction
                    });
                }
            }, 500);
        });
        
        // Also try on DOMContentLoaded for faster unlock
        document.addEventListener('DOMContentLoaded', () => {
            // Try to unlock on first pointer/mouse movement anywhere
            const unlockOnFirstMove = () => {
                if (!isAudioUnlocked && teamCardPaperFlipSound) {
                    unlockAudio();
                }
            };
            document.addEventListener('pointermove', unlockOnFirstMove, { once: true, passive: true });
            document.addEventListener('mousemove', unlockOnFirstMove, { once: true, passive: true });
        });
        
        // Wait for all images to load before positioning
        // Map card IDs to team_card IDs
        const cardIdMap = {
            'poster-1': 'team_card1',
            'poster-2': 'team_card2',
            'poster-3': 'team_card3',
            'poster-4': 'team_card4'
        };
        
        cards.forEach((card, index) => {
            // Get the correct cardId from the card's HTML ID
            const cardId = cardIdMap[card.id] || `team_card${index + 1}`;
            const angle = cardAngles[cardId] || 0; // Use fixed angle for this specific card
            const img = card.querySelector('img');
            
            // Make sure card is visible
            card.style.display = 'block';
            card.style.visibility = 'visible';
            
            // Unlock audio when user interacts with card (mousedown counts as user interaction)
            // This happens before mouseenter, so audio will be ready for hover
            card.addEventListener('mousedown', function() {
                if (teamCardPaperFlipSound && !isAudioUnlocked) {
                    unlockAudio();
                }
            });
            
            // Also unlock on pointerdown (works for both mouse and touch)
            card.addEventListener('pointerdown', function() {
                if (teamCardPaperFlipSound && !isAudioUnlocked) {
                    unlockAudio();
                }
            });
            
            // Also unlock on touch for mobile
            card.addEventListener('touchstart', function() {
                if (teamCardPaperFlipSound && !isAudioUnlocked) {
                    unlockAudio();
                }
            });
            
            // Add hover effect that scales while preserving rotation
            card.addEventListener('mouseenter', async function() {
                this.style.transform = `${this.dataset.originalTransform} scale(1.1)`;
                
                // Play paper flip sound on hover
                if (teamCardPaperFlipSound) {
                    // If audio is already unlocked, just play it
                    if (isAudioUnlocked) {
                        teamCardPaperFlipSound.currentTime = 0;
                        teamCardPaperFlipSound.play().catch(() => {
                            // Ignore errors
                        });
                    } else {
                        // Audio not unlocked yet - try to unlock and play immediately
                        // Try to unlock by playing (mouseenter might be considered interaction in some cases)
                        try {
                            await teamCardPaperFlipSound.play();
                            // Success! Audio is unlocked
                            teamCardPaperFlipSound.pause();
                            teamCardPaperFlipSound.currentTime = 0;
                            isAudioUnlocked = true;
                            // Now play for real
                            teamCardPaperFlipSound.currentTime = 0;
                            await teamCardPaperFlipSound.play();
                        } catch (error) {
                            // mouseenter alone might not work, try unlocking via the unlock function
                            unlockAudio();
                            // Wait a moment for unlock to complete
                            await new Promise(resolve => setTimeout(resolve, 100));
                            if (isAudioUnlocked && teamCardPaperFlipSound) {
                                teamCardPaperFlipSound.currentTime = 0;
                                teamCardPaperFlipSound.play().catch(() => {
                                    // Ignore errors
                                });
                            }
                        }
                    }
                }
            });
            
            // Also unlock on pointerenter (works for both mouse and touch)
            card.addEventListener('pointerenter', function() {
                if (teamCardPaperFlipSound && !isAudioUnlocked) {
                    unlockAudio();
                }
            });
            
            card.addEventListener('mouseleave', function() {
                this.style.transform = this.dataset.originalTransform;
                
                // Reset sound for next play
                if (teamCardPaperFlipSound) {
                    teamCardPaperFlipSound.pause();
                    teamCardPaperFlipSound.currentTime = 0;
                }
            });
            
            // Position card when image loads
            if (img.complete && img.naturalWidth > 0) {
                positionCard(card, img, angle, containerWidth, containerHeight, edgePadding, cardId);
            } else {
                img.addEventListener('load', function() {
                    if (img.naturalWidth > 0) {
                        positionCard(card, img, angle, containerWidth, containerHeight, edgePadding, cardId);
                    }
                });
                img.addEventListener('error', function() {
                    console.warn('Failed to load image for card:', card.id);
                });
            }
        });
    
        function positionCard(card, img, angle, containerWidth, containerHeight, edgePadding, cardId) {
            const imgWidth = img.naturalWidth || img.width;
            const imgHeight = img.naturalHeight || img.height;
            
            // Account for rotation by using diagonal (worst case)
            const diagonal = Math.sqrt(imgWidth * imgWidth + imgHeight * imgHeight);
            const halfDiagonal = diagonal / 2;
            
            // Store card data for positioning with cardId
            cardData.push({
                card: card,
                img: img,
                angle: angle,
                diagonal: diagonal,
                halfDiagonal: halfDiagonal,
                cardId: cardId
            });
            
            // If all cards are loaded, position them in a centered, separated layout
            if (cardData.length === cards.length) {
                positionAllCards(cardData);
            }
        }
        
        function positionAllCards(cardData) {
            // Gallery layout - CSS flexbox handles wrapping, we just set image sizes
            // Sort cards to ensure correct order
            const cardOrder = ['team_card1', 'team_card2', 'team_card3', 'team_card4'];
            
            // Log card dimensions for reference
            console.log('=== CARD DIMENSIONS ===');
            cardOrder.forEach(cardId => {
                const data = cardData.find(d => d.cardId === cardId);
                if (data) {
                    const imgWidth = data.img.naturalWidth || data.img.width || 0;
                    const imgHeight = data.img.naturalHeight || data.img.height || 0;
                    console.log(`${cardId}: ${imgWidth}px × ${imgHeight}px`);
                }
            });
            console.log('=======================');
            const sortedCardData = cardOrder.map(cardId => {
                return cardData.find(data => data.cardId === cardId);
            }).filter(Boolean);
            
            // Update cardData to sorted order
            cardData.length = 0;
            cardData.push(...sortedCardData);
            
            // Define different rotation angles for each card (poster-like misalignment)
            const cardRotations = {
                'team_card1': -15,   // Rotate left
                'team_card2': 12,    // Rotate right
                'team_card3': -10,   // Rotate left
                'team_card4': 8      // Rotate right
            };
            
            // Simply set image sizes - CSS flexbox will handle positioning and wrapping
            cardData.forEach((data) => {
                const cardImg = data.card.querySelector('img');
                if (cardImg) {
                    // Remove any absolute positioning styles
                    data.card.style.position = 'relative';
                    data.card.style.left = 'auto';
                    data.card.style.top = 'auto';
                    data.card.style.display = 'block';
                    
                    // Apply rotation angle for poster-like effect
                    const rotationAngle = cardRotations[data.cardId] || 0;
                    data.card.style.transform = `rotate(${rotationAngle}deg)`;
                    // Store rotation in CSS variable for hover effect
                    data.card.style.setProperty('--card-rotation', `${rotationAngle}deg`);
                    
                    // Let CSS handle sizing - images will scale responsively
                    cardImg.style.width = '100%';
                    cardImg.style.height = 'auto';
                    cardImg.style.maxWidth = '100%';
                    cardImg.style.display = 'block';
                }
                
                // Remove any existing card labels
                const existingLabel = data.card.querySelector('.card-label');
                if (existingLabel) {
                    existingLabel.remove();
                }
                
                // Remove any existing overlays (names and X logos only show in popup)
                const existingOverlay = data.card.querySelector('.card-overlay');
                if (existingOverlay) {
                    existingOverlay.remove();
                }
            });
        }
        
        // No need for resize handler - CSS flexbox handles responsive layout automatically
        
        // PIXI.js Instruction System (matching index.html)
        let instructionApp = null;
        let instructionContainer = null;
        let instructionAlpha = 1.0;
        let instructionAnimationId = null;
        let instructionResizeHandler = null;
        let isInstructionFading = false;
        let instructionShown = false; // Track if instruction has been shown
        let instructionScrollHandler = null; // Store scroll handler reference

        // Wait for PIXI.js to load
        (async () => {
            while (typeof PIXI === 'undefined') {
                await new Promise(resolve => setTimeout(resolve, 10));
            }

            // Function to detect scrollable directions
            function detectScrollableDirections() {
                const viewportWidth = window.innerWidth;
                const viewportHeight = window.innerHeight;
                const body = document.body;
                const html = document.documentElement;
                
                // Get actual content dimensions - use scrollHeight/scrollWidth for accurate measurement
                const contentWidth = Math.max(
                    body.scrollWidth,
                    html.scrollWidth
                );
                const contentHeight = Math.max(
                    body.scrollHeight,
                    html.scrollHeight
                );
                
                // Add a small threshold (5px) to prevent false positives from rounding errors
                const scrollThreshold = 5;
                const needsHorizontalScroll = contentWidth > (viewportWidth + scrollThreshold);
                const needsVerticalScroll = contentHeight > (viewportHeight + scrollThreshold);
                
                return {
                    horizontal: needsHorizontalScroll,
                    vertical: needsVerticalScroll,
                    contentWidth: contentWidth,
                    contentHeight: contentHeight,
                    viewportWidth: viewportWidth,
                    viewportHeight: viewportHeight
                };
            }

            // Function to create swipe animation (mobile) - matching index.html
            function createSwipeAnimation(container, scrollInfo) {
                const centerX = instructionApp.screen.width / 2;
                const centerY = instructionApp.screen.height / 2;
                const viewportWidth = instructionApp.screen.width;
                const viewportHeight = instructionApp.screen.height;
                const minDimension = Math.min(viewportWidth, viewportHeight);
                const fingerSize = Math.max(18, Math.min(30, 25 * (minDimension / 800)));

                // Determine animation direction based on scrollable directions
                let startX, startY, endX, endY;
                let isHorizontal = false;
                let instructionText = '';

                if (scrollInfo.horizontal && scrollInfo.vertical) {
                    // Both directions scrollable - prioritize horizontal for smaller screens
                    if (scrollInfo.viewportWidth < scrollInfo.viewportHeight) {
                        // Portrait or narrow screen - show horizontal
                        isHorizontal = true;
                        startX = instructionApp.screen.width * 0.3;
                        endX = instructionApp.screen.width * 0.7;
                        startY = centerY;
                        endY = centerY;
                        instructionText = 'Long press and swipe left/right to explore';
                    } else {
                        // Landscape or wide screen - show vertical
                        isHorizontal = false;
                        startX = centerX;
                        endX = centerX;
                        startY = instructionApp.screen.height * 0.3;
                        endY = instructionApp.screen.height * 0.7;
                        instructionText = 'Long press and swipe up/down to explore';
                    }
                } else if (scrollInfo.horizontal) {
                    // Only horizontal scrolling needed
                    isHorizontal = true;
                    startX = instructionApp.screen.width * 0.3;
                    endX = instructionApp.screen.width * 0.7;
                    startY = centerY;
                    endY = centerY;
                    instructionText = 'Long press and swipe left/right to explore';
                } else if (scrollInfo.vertical) {
                    // Only vertical scrolling needed
                    isHorizontal = false;
                    startX = centerX;
                    endX = centerX;
                    startY = instructionApp.screen.height * 0.3;
                    endY = instructionApp.screen.height * 0.7;
                    instructionText = 'Long press and swipe up/down to explore';
                } else {
                    // No scrolling needed
                    return;
                }

                // Create finger/hand graphic
                const finger = new PIXI.Graphics();

                const drawFinger = (x, y, isPressing = false) => {
                    if (!finger || finger.destroyed) return;
                    finger.clear();
                    // Draw finger as a circle
                    finger.circle(0, 0, fingerSize);
                    finger.fill({ color: 0xFFFFFF, alpha: 0.9 });
                    finger.stroke({ color: 0x333333, width: 2 });

                    // Add press indicator
                    if (isPressing) {
                        finger.circle(0, 0, fingerSize * 0.7);
                        finger.fill({ color: 0x4CAF50, alpha: 0.6 });
                    }
                };

                finger.x = centerX;
                finger.y = startY;
                drawFinger(0, 0, false);
                container.addChild(finger);

                // Create swipe trail
                const trailGraphics = new PIXI.Graphics();
                container.addChild(trailGraphics);

                // Animation state
                let animTime = 0;
                const animDuration = 3000; // 3 seconds per cycle

                // Animation loop
                instructionAnimationId = instructionApp.ticker.add(() => {
                    if (!instructionContainer || !instructionContainer.visible || instructionContainer.destroyed) return;
                    if (!finger || finger.destroyed || !trailGraphics || trailGraphics.destroyed) return;

                    animTime += instructionApp.ticker.deltaMS;
                    if (animTime >= animDuration) {
                        animTime = 0;
                    }

                    const progress = (animTime % animDuration) / animDuration;

                    // Long press phase (first 30% of animation)
                    if (progress < 0.3) {
                        finger.x = startX;
                        finger.y = startY;
                        const pressProgress = progress / 0.3;
                        drawFinger(0, 0, true);

                        // Draw press indicator (expanding circle)
                        if (trailGraphics && !trailGraphics.destroyed) {
                            trailGraphics.clear();
                            const pressRadius = 15 + pressProgress * 20;
                            trailGraphics.circle(startX, startY, pressRadius);
                            trailGraphics.stroke({ color: 0x4CAF50, width: 2, alpha: 0.6 - pressProgress * 0.4 });
                        }
                    } else {
                        // Swipe phase (remaining 70%)
                        const swipeProgress = (progress - 0.3) / 0.7;

                        let easeProgress;
                        let currentX, currentY;

                        if (swipeProgress < 0.5) {
                            const moveProgress = swipeProgress * 2;
                            easeProgress = moveProgress < 0.5
                                ? 2 * moveProgress * moveProgress
                                : 1 - Math.pow(-2 * moveProgress + 2, 2) / 2;

                            if (isHorizontal) {
                                currentX = startX + (endX - startX) * easeProgress;
                                currentY = startY;
                            } else {
                                currentX = startX;
                                currentY = startY + (endY - startY) * easeProgress;
                            }
                        } else {
                            const backProgress = (swipeProgress - 0.5) * 2;
                            easeProgress = backProgress < 0.5
                                ? 2 * backProgress * backProgress
                                : 1 - Math.pow(-2 * backProgress + 2, 2) / 2;

                            if (isHorizontal) {
                                currentX = endX - (endX - startX) * easeProgress;
                                currentY = startY;
                            } else {
                                currentX = startX;
                                currentY = endY - (endY - startY) * easeProgress;
                            }
                        }

                        finger.x = currentX;
                        finger.y = currentY;
                        drawFinger(0, 0, true);

                        // Draw swipe trail
                        if (trailGraphics && !trailGraphics.destroyed) {
                            trailGraphics.clear();
                            const trailPoints = 20;
                            for (let i = 0; i <= trailPoints; i++) {
                                const trailProgress = Math.max(0, easeProgress - (i / trailPoints) * 0.5);
                                if (trailProgress > 0) {
                                    let trailX, trailY;
                                    if (swipeProgress < 0.5) {
                                        if (isHorizontal) {
                                            trailX = startX + (endX - startX) * trailProgress;
                                            trailY = startY;
                                        } else {
                                            trailX = startX;
                                            trailY = startY + (endY - startY) * trailProgress;
                                        }
                                    } else {
                                        const backProgress = (swipeProgress - 0.5) * 2;
                                        const backEase = backProgress < 0.5
                                            ? 2 * backProgress * backProgress
                                            : 1 - Math.pow(-2 * backProgress + 2, 2) / 2;
                                        if (isHorizontal) {
                                            trailX = endX - (endX - startX) * backEase;
                                            trailY = startY;
                                        } else {
                                            trailX = startX;
                                            trailY = endY - (endY - startY) * backEase;
                                        }
                                    }
                                    trailGraphics.circle(trailX, trailY, 4 - (i * 0.15));
                                    trailGraphics.fill({ color: 0xFFFFFF, alpha: 0.4 - (i * 0.02) });
                                }
                            }
                        }
                    }
                });

                // Calculate responsive font size
                const baseFontSize = 24;
                const minFontSize = 14;
                const maxFontSize = 28;
                const minDimensionForFont = Math.min(viewportWidth, viewportHeight);
                const fontSize = Math.max(minFontSize, Math.min(maxFontSize, baseFontSize * (minDimensionForFont / 800)));

                // Add instruction text
                const instructionTextElement = new PIXI.Text({
                    text: instructionText,
                    style: {
                        fontFamily: 'Arial, sans-serif',
                        fontSize: fontSize,
                        fill: 0xFFFFFF,
                        align: 'center',
                        fontWeight: 'bold',
                        dropShadow: true,
                        dropShadowColor: 0x000000,
                        dropShadowDistance: 2,
                        dropShadowBlur: 4,
                        wordWrap: true,
                        wordWrapWidth: viewportWidth * 0.9,
                    }
                });
                instructionTextElement.anchor.set(0.5);
                instructionTextElement.x = instructionApp.screen.width / 2;
                instructionTextElement.y = instructionApp.screen.height * 0.85;
                container.addChild(instructionTextElement);
            }

            // Function to show instruction animation
            async function showInstructionAnimation() {
                // Check if mobile/tablet
                const isMobile = window.innerWidth <= 1024;
                if (!isMobile) return;

                // Prevent showing instructions multiple times
                if (instructionShown || isInstructionFading) return;
                
                // Check if instruction container already exists
                const canvasContainer = document.getElementById('instruction-canvas-container');
                if (!canvasContainer) return;
                if (canvasContainer.style.display === 'block') return;

                // Detect scrollable directions
                const scrollInfo = detectScrollableDirections();
                if (!scrollInfo.horizontal && !scrollInfo.vertical) return;

                // Create PIXI application

                instructionApp = new PIXI.Application();
                await instructionApp.init({
                    width: window.innerWidth,
                    height: window.innerHeight,
                    backgroundColor: 0x000000,
                    backgroundAlpha: 0.3,
                    antialias: true,
                    autoDensity: true,
                    resolution: window.devicePixelRatio || 1,
                });

                canvasContainer.appendChild(instructionApp.canvas);
                canvasContainer.style.display = 'block';
                
                // Mark instruction as shown
                instructionShown = true;

                // Create instruction container
                instructionContainer = new PIXI.Container();
                instructionContainer.zIndex = 9998;
                instructionContainer.alpha = instructionAlpha;
                instructionContainer.eventMode = 'passive';

                // Create semi-transparent overlay
                const overlay = new PIXI.Graphics();
                overlay.rect(0, 0, instructionApp.screen.width, instructionApp.screen.height);
                overlay.fill({ color: 0x000000, alpha: 0.3 });
                instructionContainer.addChild(overlay);

                // Create swipe animation
                createSwipeAnimation(instructionContainer, scrollInfo);

                // Add to stage
                instructionApp.stage.addChild(instructionContainer);

                // Handle window resize
                instructionResizeHandler = () => {
                    if (!instructionContainer || !instructionApp) return;
                    instructionApp.renderer.resize(window.innerWidth, window.innerHeight);
                    
                    const overlay = instructionContainer.children[0];
                    if (overlay && overlay instanceof PIXI.Graphics) {
                        overlay.clear();
                        overlay.rect(0, 0, instructionApp.screen.width, instructionApp.screen.height);
                        overlay.fill({ color: 0x000000, alpha: 0.3 });
                    }

                    instructionContainer.children.forEach((child) => {
                        if (child instanceof PIXI.Text) {
                            if (child.text.includes('Long press') || child.text.includes('explore')) {
                                child.x = instructionApp.screen.width / 2;
                                child.y = instructionApp.screen.height * 0.85;
                            }
                        }
                    });
                };

                window.addEventListener('resize', instructionResizeHandler);

                // Auto-fade after 4 seconds
                setTimeout(() => {
                    fadeOutInstruction();
                }, 4000);

                // Hide on any interaction
                const hideOnInteraction = () => {
                    if (instructionContainer && instructionContainer.visible) {
                        fadeOutInstruction();
                    }
                };

                instructionApp.canvas.addEventListener('pointerdown', hideOnInteraction, { once: true });
                instructionApp.canvas.addEventListener('touchstart', hideOnInteraction, { once: true });
                instructionApp.canvas.addEventListener('mousedown', hideOnInteraction, { once: true });
                
                // Hide on scroll - use a more robust scroll listener
                let scrollTimeout;
                instructionScrollHandler = () => {
                    if (instructionContainer && instructionContainer.visible) {
                        clearTimeout(scrollTimeout);
                        scrollTimeout = setTimeout(() => {
                            fadeOutInstruction();
                        }, 100);
                    }
                };
                window.addEventListener('scroll', instructionScrollHandler, { passive: true });
                // Also listen for touchmove to catch swipe gestures
                window.addEventListener('touchmove', instructionScrollHandler, { passive: true });
            }

            // Function to fade out instruction
            function fadeOutInstruction() {
                if (isInstructionFading || !instructionContainer || !instructionContainer.parent) return;

                isInstructionFading = true;
                instructionShown = true; // Mark as shown to prevent re-showing

                // Remove animation ticker
                if (instructionAnimationId !== null) {
                    instructionApp.ticker.remove(instructionAnimationId);
                    instructionAnimationId = null;
                }

                // Remove resize listener
                if (instructionResizeHandler) {
                    window.removeEventListener('resize', instructionResizeHandler);
                    instructionResizeHandler = null;
                }
                
                // Remove scroll and touch listeners (they're added in showInstructionAnimation)
                if (instructionScrollHandler) {
                    window.removeEventListener('scroll', instructionScrollHandler);
                    window.removeEventListener('touchmove', instructionScrollHandler);
                    instructionScrollHandler = null;
                }

                // Fade out
                const fadeOut = instructionApp.ticker.add(() => {
                    instructionAlpha -= 0.02;
                    if (instructionAlpha <= 0) {
                        instructionAlpha = 0;
                        instructionApp.ticker.remove(fadeOut);
                        if (instructionContainer && instructionContainer.parent) {
                            instructionContainer.parent.removeChild(instructionContainer);
                        }
                        if (instructionApp && instructionApp.canvas && instructionApp.canvas.parentNode) {
                            instructionApp.canvas.parentNode.removeChild(instructionApp.canvas);
                            instructionApp.destroy(true);
                            instructionApp = null;
                        }
                        const canvasContainer = document.getElementById('instruction-canvas-container');
                        if (canvasContainer) canvasContainer.style.display = 'none';
                        isInstructionFading = false;
                        instructionAlpha = 1.0;
                    } else {
                        if (instructionContainer) instructionContainer.alpha = instructionAlpha;
                    }
                });
            }

            // Show instruction after page loads
            window.addEventListener('load', () => {
                setTimeout(() => {
                    showInstructionAnimation();
                }, 1500);
            });

            // Check on resize - but don't re-show instructions if they've already been shown
            let resizeTimeout;
            window.addEventListener('resize', () => {
                clearTimeout(resizeTimeout);
                // Only handle resize for existing instruction app, don't re-show instructions
                resizeTimeout = setTimeout(() => {
                    if (instructionApp && instructionResizeHandler) {
                        instructionResizeHandler();
                    }
                }, 100);
            });
        })();
    </script>
</body>
</html>